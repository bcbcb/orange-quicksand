<!DOCTYPE html>

<html>
<head>
  <title>resize.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../../../../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>resize.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>JavaScript Image Resizer (c) 2012 - Grant Galitz</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> scripts = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"script"</span>);
<span class="hljs-keyword">var</span> sourceOfWorker = scripts[scripts.length-<span class="hljs-number">1</span>].src;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Resize</span><span class="hljs-params">(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, useWebWorker, resizeCallback)</span> </span>{
	<span class="hljs-keyword">this</span>.widthOriginal = <span class="hljs-built_in">Math</span>.abs(<span class="hljs-built_in">parseInt</span>(widthOriginal) || <span class="hljs-number">0</span>);
	<span class="hljs-keyword">this</span>.heightOriginal = <span class="hljs-built_in">Math</span>.abs(<span class="hljs-built_in">parseInt</span>(heightOriginal) || <span class="hljs-number">0</span>);
	<span class="hljs-keyword">this</span>.targetWidth = <span class="hljs-built_in">Math</span>.abs(<span class="hljs-built_in">parseInt</span>(targetWidth) || <span class="hljs-number">0</span>);
	<span class="hljs-keyword">this</span>.targetHeight = <span class="hljs-built_in">Math</span>.abs(<span class="hljs-built_in">parseInt</span>(targetHeight) || <span class="hljs-number">0</span>);
	<span class="hljs-keyword">this</span>.colorChannels = (!!blendAlpha) ? <span class="hljs-number">4</span> : <span class="hljs-number">3</span>;
	<span class="hljs-keyword">this</span>.interpolationPass = !!interpolationPass;
	<span class="hljs-keyword">this</span>.useWebWorker = !!useWebWorker;
	<span class="hljs-keyword">this</span>.resizeCallback = (<span class="hljs-keyword">typeof</span> resizeCallback == <span class="hljs-string">"function"</span>) ? resizeCallback : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(returnedArray)</span> </span>{};
	<span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels = <span class="hljs-keyword">this</span>.targetWidth * <span class="hljs-keyword">this</span>.colorChannels;
	<span class="hljs-keyword">this</span>.originalWidthMultipliedByChannels = <span class="hljs-keyword">this</span>.widthOriginal * <span class="hljs-keyword">this</span>.colorChannels;
	<span class="hljs-keyword">this</span>.originalHeightMultipliedByChannels = <span class="hljs-keyword">this</span>.heightOriginal * <span class="hljs-keyword">this</span>.colorChannels;
	<span class="hljs-keyword">this</span>.widthPassResultSize = <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels * <span class="hljs-keyword">this</span>.heightOriginal;
	<span class="hljs-keyword">this</span>.finalResultSize = <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels * <span class="hljs-keyword">this</span>.targetHeight;
	<span class="hljs-keyword">this</span>.initialize();
}
Resize.prototype.initialize = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>Perform some checks:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.widthOriginal &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.heightOriginal &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.targetWidth &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">this</span>.targetHeight &gt; <span class="hljs-number">0</span>) {
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.useWebWorker) {
			<span class="hljs-keyword">this</span>.useWebWorker = (<span class="hljs-keyword">this</span>.widthOriginal != <span class="hljs-keyword">this</span>.targetWidth || <span class="hljs-keyword">this</span>.heightOriginal != <span class="hljs-keyword">this</span>.targetHeight);
			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.useWebWorker) {
				<span class="hljs-keyword">this</span>.configureWorker();
			}
		}
		<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.useWebWorker) {
			<span class="hljs-keyword">this</span>.configurePasses();
		}
	}
	<span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Invalid settings specified for the resizer."</span>));
	}
}
Resize.prototype.configureWorker = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
	<span class="hljs-keyword">try</span> {
		<span class="hljs-keyword">var</span> parentObj = <span class="hljs-keyword">this</span>;
		<span class="hljs-keyword">this</span>.worker = <span class="hljs-keyword">new</span> Worker(sourceOfWorker.substring(<span class="hljs-number">0</span>, sourceOfWorker.length - <span class="hljs-number">3</span>) + <span class="hljs-string">"Worker.js"</span>);
		<span class="hljs-keyword">this</span>.worker.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event)</span> </span>{
			parentObj.heightBuffer = event.data;
			parentObj.resizeCallback(parentObj.heightBuffer);
		}
		<span class="hljs-keyword">this</span>.worker.postMessage([<span class="hljs-string">"setup"</span>, <span class="hljs-keyword">this</span>.widthOriginal, <span class="hljs-keyword">this</span>.heightOriginal, <span class="hljs-keyword">this</span>.targetWidth, <span class="hljs-keyword">this</span>.targetHeight, <span class="hljs-keyword">this</span>.colorChannels, <span class="hljs-keyword">this</span>.interpolationPass]);
	}
	<span class="hljs-keyword">catch</span> (error) {
		<span class="hljs-keyword">this</span>.useWebWorker = <span class="hljs-literal">false</span>;
	}
}
Resize.prototype.configurePasses = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.widthOriginal == <span class="hljs-keyword">this</span>.targetWidth) {</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Bypass the width resizer pass:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">this</span>.resizeWidth = <span class="hljs-keyword">this</span>.bypassResizer;
	}
	<span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Setup the width resizer pass:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">this</span>.ratioWeightWidthPass = <span class="hljs-keyword">this</span>.widthOriginal / <span class="hljs-keyword">this</span>.targetWidth;
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ratioWeightWidthPass &lt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-keyword">this</span>.interpolationPass) {
			<span class="hljs-keyword">this</span>.initializeFirstPassBuffers(<span class="hljs-literal">true</span>);
			<span class="hljs-keyword">this</span>.resizeWidth = (<span class="hljs-keyword">this</span>.colorChannels == <span class="hljs-number">4</span>) ? <span class="hljs-keyword">this</span>.resizeWidthInterpolatedRGBA : <span class="hljs-keyword">this</span>.resizeWidthInterpolatedRGB;
		}
		<span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">this</span>.initializeFirstPassBuffers(<span class="hljs-literal">false</span>);
			<span class="hljs-keyword">this</span>.resizeWidth = (<span class="hljs-keyword">this</span>.colorChannels == <span class="hljs-number">4</span>) ? <span class="hljs-keyword">this</span>.resizeWidthRGBA : <span class="hljs-keyword">this</span>.resizeWidthRGB;
		}
	}
	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.heightOriginal == <span class="hljs-keyword">this</span>.targetHeight) {</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Bypass the height resizer pass:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">this</span>.resizeHeight = <span class="hljs-keyword">this</span>.bypassResizer;
	}
	<span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Setup the height resizer pass:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">this</span>.ratioWeightHeightPass = <span class="hljs-keyword">this</span>.heightOriginal / <span class="hljs-keyword">this</span>.targetHeight;
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.ratioWeightHeightPass &lt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-keyword">this</span>.interpolationPass) {
			<span class="hljs-keyword">this</span>.initializeSecondPassBuffers(<span class="hljs-literal">true</span>);
			<span class="hljs-keyword">this</span>.resizeHeight = <span class="hljs-keyword">this</span>.resizeHeightInterpolated;
		}
		<span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">this</span>.initializeSecondPassBuffers(<span class="hljs-literal">false</span>);
			<span class="hljs-keyword">this</span>.resizeHeight = (<span class="hljs-keyword">this</span>.colorChannels == <span class="hljs-number">4</span>) ? <span class="hljs-keyword">this</span>.resizeHeightRGBA : <span class="hljs-keyword">this</span>.resizeHeightRGB;
		}
	}
}
Resize.prototype.resizeWidthRGB = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer)</span> </span>{
	<span class="hljs-keyword">var</span> ratioWeight = <span class="hljs-keyword">this</span>.ratioWeightWidthPass;
	<span class="hljs-keyword">var</span> ratioWeightDivisor = <span class="hljs-number">1</span> / ratioWeight;
	<span class="hljs-keyword">var</span> weight = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> amountToNext = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> actualPosition = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> currentPosition = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> line = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> pixelOffset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> outputOffset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> nextLineOffsetOriginalWidth = <span class="hljs-keyword">this</span>.originalWidthMultipliedByChannels - <span class="hljs-number">2</span>;
	<span class="hljs-keyword">var</span> nextLineOffsetTargetWidth = <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels - <span class="hljs-number">2</span>;
	<span class="hljs-keyword">var</span> output = <span class="hljs-keyword">this</span>.outputWidthWorkBench;
	<span class="hljs-keyword">var</span> outputBuffer = <span class="hljs-keyword">this</span>.widthBuffer;
	<span class="hljs-keyword">do</span> {
		<span class="hljs-keyword">for</span> (line = <span class="hljs-number">0</span>; line &lt; <span class="hljs-keyword">this</span>.originalHeightMultipliedByChannels;) {
			output[line++] = <span class="hljs-number">0</span>;
			output[line++] = <span class="hljs-number">0</span>;
			output[line++] = <span class="hljs-number">0</span>;
		}
		weight = ratioWeight;
		<span class="hljs-keyword">do</span> {
			amountToNext = <span class="hljs-number">1</span> + actualPosition - currentPosition;
			<span class="hljs-keyword">if</span> (weight &gt;= amountToNext) {
				<span class="hljs-keyword">for</span> (line = <span class="hljs-number">0</span>, pixelOffset = actualPosition; line &lt; <span class="hljs-keyword">this</span>.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {
					output[line++] += buffer[pixelOffset++] * amountToNext;
					output[line++] += buffer[pixelOffset++] * amountToNext;
					output[line++] += buffer[pixelOffset] * amountToNext;
				}
				currentPosition = actualPosition = actualPosition + <span class="hljs-number">3</span>;
				weight -= amountToNext;
			}
			<span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">for</span> (line = <span class="hljs-number">0</span>, pixelOffset = actualPosition; line &lt; <span class="hljs-keyword">this</span>.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {
					output[line++] += buffer[pixelOffset++] * weight;
					output[line++] += buffer[pixelOffset++] * weight;
					output[line++] += buffer[pixelOffset] * weight;
				}
				currentPosition += weight;
				<span class="hljs-keyword">break</span>;
			}
		} <span class="hljs-keyword">while</span> (weight &gt; <span class="hljs-number">0</span> &amp;&amp; actualPosition &lt; <span class="hljs-keyword">this</span>.originalWidthMultipliedByChannels);
		<span class="hljs-keyword">for</span> (line = <span class="hljs-number">0</span>, pixelOffset = outputOffset; line &lt; <span class="hljs-keyword">this</span>.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {
			outputBuffer[pixelOffset++] = output[line++] * ratioWeightDivisor;
			outputBuffer[pixelOffset++] = output[line++] * ratioWeightDivisor;
			outputBuffer[pixelOffset] = output[line++] * ratioWeightDivisor;
		}
		outputOffset += <span class="hljs-number">3</span>;
	} <span class="hljs-keyword">while</span> (outputOffset &lt; <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels);
	<span class="hljs-keyword">return</span> outputBuffer;
}
Resize.prototype.resizeWidthInterpolatedRGB = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer)</span> </span>{
	<span class="hljs-keyword">var</span> ratioWeight = <span class="hljs-keyword">this</span>.ratioWeightWidthPass;
	<span class="hljs-keyword">var</span> weight = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> finalOffset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> pixelOffset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> firstWeight = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> secondWeight = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> outputBuffer = <span class="hljs-keyword">this</span>.widthBuffer;</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Handle for only one interpolation input being valid for start calculation:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> targetPosition = <span class="hljs-number">0</span>; weight &lt; <span class="hljs-number">1</span>/<span class="hljs-number">3</span>; targetPosition += <span class="hljs-number">3</span>, weight += ratioWeight) {
		<span class="hljs-keyword">for</span> (finalOffset = targetPosition, pixelOffset = <span class="hljs-number">0</span>; finalOffset &lt; <span class="hljs-keyword">this</span>.widthPassResultSize; pixelOffset += <span class="hljs-keyword">this</span>.originalWidthMultipliedByChannels, finalOffset += <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels) {
			outputBuffer[finalOffset] = buffer[pixelOffset];
			outputBuffer[finalOffset + <span class="hljs-number">1</span>] = buffer[pixelOffset + <span class="hljs-number">1</span>];
			outputBuffer[finalOffset + <span class="hljs-number">2</span>] = buffer[pixelOffset + <span class="hljs-number">2</span>];
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Adjust for overshoot of the last pass’s counter:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	weight -= <span class="hljs-number">1</span>/<span class="hljs-number">3</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> interpolationWidthSourceReadStop = <span class="hljs-keyword">this</span>.widthOriginal - <span class="hljs-number">1</span>; weight &lt; interpolationWidthSourceReadStop; targetPosition += <span class="hljs-number">3</span>, weight += ratioWeight) {</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Calculate weightings:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		secondWeight = weight % <span class="hljs-number">1</span>;
		firstWeight = <span class="hljs-number">1</span> - secondWeight;</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Interpolate:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (finalOffset = targetPosition, pixelOffset = <span class="hljs-built_in">Math</span>.floor(weight) * <span class="hljs-number">3</span>; finalOffset &lt; <span class="hljs-keyword">this</span>.widthPassResultSize; pixelOffset += <span class="hljs-keyword">this</span>.originalWidthMultipliedByChannels, finalOffset += <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels) {
			outputBuffer[finalOffset] = (buffer[pixelOffset] * firstWeight) + (buffer[pixelOffset + <span class="hljs-number">3</span>] * secondWeight);
			outputBuffer[finalOffset + <span class="hljs-number">1</span>] = (buffer[pixelOffset + <span class="hljs-number">1</span>] * firstWeight) + (buffer[pixelOffset + <span class="hljs-number">4</span>] * secondWeight);
			outputBuffer[finalOffset + <span class="hljs-number">2</span>] = (buffer[pixelOffset + <span class="hljs-number">2</span>] * firstWeight) + (buffer[pixelOffset + <span class="hljs-number">5</span>] * secondWeight);
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Handle for only one interpolation input being valid for end calculation:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (interpolationWidthSourceReadStop = <span class="hljs-keyword">this</span>.originalWidthMultipliedByChannels - <span class="hljs-number">3</span>; targetPosition &lt; <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels; targetPosition += <span class="hljs-number">3</span>) {
		<span class="hljs-keyword">for</span> (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop; finalOffset &lt; <span class="hljs-keyword">this</span>.widthPassResultSize; pixelOffset += <span class="hljs-keyword">this</span>.originalWidthMultipliedByChannels, finalOffset += <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels) {
			outputBuffer[finalOffset] = buffer[pixelOffset];
			outputBuffer[finalOffset + <span class="hljs-number">1</span>] = buffer[pixelOffset + <span class="hljs-number">1</span>];
			outputBuffer[finalOffset + <span class="hljs-number">2</span>] = buffer[pixelOffset + <span class="hljs-number">2</span>];
		}
	}
	<span class="hljs-keyword">return</span> outputBuffer;
}
Resize.prototype.resizeWidthRGBA = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer)</span> </span>{
	<span class="hljs-keyword">var</span> ratioWeight = <span class="hljs-keyword">this</span>.ratioWeightWidthPass;
	<span class="hljs-keyword">var</span> ratioWeightDivisor = <span class="hljs-number">1</span> / ratioWeight;
	<span class="hljs-keyword">var</span> weight = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> amountToNext = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> actualPosition = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> currentPosition = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> line = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> pixelOffset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> outputOffset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> nextLineOffsetOriginalWidth = <span class="hljs-keyword">this</span>.originalWidthMultipliedByChannels - <span class="hljs-number">3</span>;
	<span class="hljs-keyword">var</span> nextLineOffsetTargetWidth = <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels - <span class="hljs-number">3</span>;
	<span class="hljs-keyword">var</span> output = <span class="hljs-keyword">this</span>.outputWidthWorkBench;
	<span class="hljs-keyword">var</span> outputBuffer = <span class="hljs-keyword">this</span>.widthBuffer;
	<span class="hljs-keyword">do</span> {
		<span class="hljs-keyword">for</span> (line = <span class="hljs-number">0</span>; line &lt; <span class="hljs-keyword">this</span>.originalHeightMultipliedByChannels;) {
			output[line++] = <span class="hljs-number">0</span>;
			output[line++] = <span class="hljs-number">0</span>;
			output[line++] = <span class="hljs-number">0</span>;
			output[line++] = <span class="hljs-number">0</span>;
		}
		weight = ratioWeight;
		<span class="hljs-keyword">do</span> {
			amountToNext = <span class="hljs-number">1</span> + actualPosition - currentPosition;
			<span class="hljs-keyword">if</span> (weight &gt;= amountToNext) {
				<span class="hljs-keyword">for</span> (line = <span class="hljs-number">0</span>, pixelOffset = actualPosition; line &lt; <span class="hljs-keyword">this</span>.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {
					output[line++] += buffer[pixelOffset++] * amountToNext;
					output[line++] += buffer[pixelOffset++] * amountToNext;
					output[line++] += buffer[pixelOffset++] * amountToNext;
					output[line++] += buffer[pixelOffset] * amountToNext;
				}
				currentPosition = actualPosition = actualPosition + <span class="hljs-number">4</span>;
				weight -= amountToNext;
			}
			<span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">for</span> (line = <span class="hljs-number">0</span>, pixelOffset = actualPosition; line &lt; <span class="hljs-keyword">this</span>.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {
					output[line++] += buffer[pixelOffset++] * weight;
					output[line++] += buffer[pixelOffset++] * weight;
					output[line++] += buffer[pixelOffset++] * weight;
					output[line++] += buffer[pixelOffset] * weight;
				}
				currentPosition += weight;
				<span class="hljs-keyword">break</span>;
			}
		} <span class="hljs-keyword">while</span> (weight &gt; <span class="hljs-number">0</span> &amp;&amp; actualPosition &lt; <span class="hljs-keyword">this</span>.originalWidthMultipliedByChannels);
		<span class="hljs-keyword">for</span> (line = <span class="hljs-number">0</span>, pixelOffset = outputOffset; line &lt; <span class="hljs-keyword">this</span>.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {
			outputBuffer[pixelOffset++] = output[line++] * ratioWeightDivisor;
			outputBuffer[pixelOffset++] = output[line++] * ratioWeightDivisor;
			outputBuffer[pixelOffset++] = output[line++] * ratioWeightDivisor;
			outputBuffer[pixelOffset] = output[line++] * ratioWeightDivisor;
		}
		outputOffset += <span class="hljs-number">4</span>;
	} <span class="hljs-keyword">while</span> (outputOffset &lt; <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels);
	<span class="hljs-keyword">return</span> outputBuffer;
}
Resize.prototype.resizeWidthInterpolatedRGBA = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer)</span> </span>{
	<span class="hljs-keyword">var</span> ratioWeight = <span class="hljs-keyword">this</span>.ratioWeightWidthPass;
	<span class="hljs-keyword">var</span> weight = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> finalOffset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> pixelOffset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> firstWeight = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> secondWeight = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> outputBuffer = <span class="hljs-keyword">this</span>.widthBuffer;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Handle for only one interpolation input being valid for start calculation:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> targetPosition = <span class="hljs-number">0</span>; weight &lt; <span class="hljs-number">1</span>/<span class="hljs-number">3</span>; targetPosition += <span class="hljs-number">4</span>, weight += ratioWeight) {
		<span class="hljs-keyword">for</span> (finalOffset = targetPosition, pixelOffset = <span class="hljs-number">0</span>; finalOffset &lt; <span class="hljs-keyword">this</span>.widthPassResultSize; pixelOffset += <span class="hljs-keyword">this</span>.originalWidthMultipliedByChannels, finalOffset += <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels) {
			outputBuffer[finalOffset] = buffer[pixelOffset];
			outputBuffer[finalOffset + <span class="hljs-number">1</span>] = buffer[pixelOffset + <span class="hljs-number">1</span>];
			outputBuffer[finalOffset + <span class="hljs-number">2</span>] = buffer[pixelOffset + <span class="hljs-number">2</span>];
			outputBuffer[finalOffset + <span class="hljs-number">3</span>] = buffer[pixelOffset + <span class="hljs-number">3</span>];
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Adjust for overshoot of the last pass’s counter:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	weight -= <span class="hljs-number">1</span>/<span class="hljs-number">3</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> interpolationWidthSourceReadStop = <span class="hljs-keyword">this</span>.widthOriginal - <span class="hljs-number">1</span>; weight &lt; interpolationWidthSourceReadStop; targetPosition += <span class="hljs-number">4</span>, weight += ratioWeight) {</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Calculate weightings:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		secondWeight = weight % <span class="hljs-number">1</span>;
		firstWeight = <span class="hljs-number">1</span> - secondWeight;</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Interpolate:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (finalOffset = targetPosition, pixelOffset = <span class="hljs-built_in">Math</span>.floor(weight) * <span class="hljs-number">4</span>; finalOffset &lt; <span class="hljs-keyword">this</span>.widthPassResultSize; pixelOffset += <span class="hljs-keyword">this</span>.originalWidthMultipliedByChannels, finalOffset += <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels) {
			outputBuffer[finalOffset] = (buffer[pixelOffset] * firstWeight) + (buffer[pixelOffset + <span class="hljs-number">4</span>] * secondWeight);
			outputBuffer[finalOffset + <span class="hljs-number">1</span>] = (buffer[pixelOffset + <span class="hljs-number">1</span>] * firstWeight) + (buffer[pixelOffset + <span class="hljs-number">5</span>] * secondWeight);
			outputBuffer[finalOffset + <span class="hljs-number">2</span>] = (buffer[pixelOffset + <span class="hljs-number">2</span>] * firstWeight) + (buffer[pixelOffset + <span class="hljs-number">6</span>] * secondWeight);
			outputBuffer[finalOffset + <span class="hljs-number">3</span>] = (buffer[pixelOffset + <span class="hljs-number">3</span>] * firstWeight) + (buffer[pixelOffset + <span class="hljs-number">7</span>] * secondWeight);
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Handle for only one interpolation input being valid for end calculation:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (interpolationWidthSourceReadStop = <span class="hljs-keyword">this</span>.originalWidthMultipliedByChannels - <span class="hljs-number">4</span>; targetPosition &lt; <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels; targetPosition += <span class="hljs-number">4</span>) {
		<span class="hljs-keyword">for</span> (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop; finalOffset &lt; <span class="hljs-keyword">this</span>.widthPassResultSize; pixelOffset += <span class="hljs-keyword">this</span>.originalWidthMultipliedByChannels, finalOffset += <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels) {
			outputBuffer[finalOffset] = buffer[pixelOffset];
			outputBuffer[finalOffset + <span class="hljs-number">1</span>] = buffer[pixelOffset + <span class="hljs-number">1</span>];
			outputBuffer[finalOffset + <span class="hljs-number">2</span>] = buffer[pixelOffset + <span class="hljs-number">2</span>];
			outputBuffer[finalOffset + <span class="hljs-number">3</span>] = buffer[pixelOffset + <span class="hljs-number">3</span>];
		}
	}
	<span class="hljs-keyword">return</span> outputBuffer;
}
Resize.prototype.resizeHeightRGB = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer)</span> </span>{
	<span class="hljs-keyword">var</span> ratioWeight = <span class="hljs-keyword">this</span>.ratioWeightHeightPass;
	<span class="hljs-keyword">var</span> ratioWeightDivisor = <span class="hljs-number">1</span> / ratioWeight;
	<span class="hljs-keyword">var</span> weight = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> amountToNext = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> actualPosition = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> currentPosition = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> pixelOffset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> outputOffset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> output = <span class="hljs-keyword">this</span>.outputHeightWorkBench;
	<span class="hljs-keyword">var</span> outputBuffer = <span class="hljs-keyword">this</span>.heightBuffer;
	<span class="hljs-keyword">do</span> {
		<span class="hljs-keyword">for</span> (pixelOffset = <span class="hljs-number">0</span>; pixelOffset &lt; <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels;) {
			output[pixelOffset++] = <span class="hljs-number">0</span>;
			output[pixelOffset++] = <span class="hljs-number">0</span>;
			output[pixelOffset++] = <span class="hljs-number">0</span>;
		}
		weight = ratioWeight;
		<span class="hljs-keyword">do</span> {
			amountToNext = <span class="hljs-number">1</span> + actualPosition - currentPosition;
			<span class="hljs-keyword">if</span> (weight &gt;= amountToNext) {
				<span class="hljs-keyword">for</span> (pixelOffset = <span class="hljs-number">0</span>; pixelOffset &lt; <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels;) {
					output[pixelOffset++] += buffer[actualPosition++] * amountToNext;
					output[pixelOffset++] += buffer[actualPosition++] * amountToNext;
					output[pixelOffset++] += buffer[actualPosition++] * amountToNext;
				}
				currentPosition = actualPosition;
				weight -= amountToNext;
			}
			<span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">for</span> (pixelOffset = <span class="hljs-number">0</span>, amountToNext = actualPosition; pixelOffset &lt; <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels;) {
					output[pixelOffset++] += buffer[amountToNext++] * weight;
					output[pixelOffset++] += buffer[amountToNext++] * weight;
					output[pixelOffset++] += buffer[amountToNext++] * weight;
				}
				currentPosition += weight;
				<span class="hljs-keyword">break</span>;
			}
		} <span class="hljs-keyword">while</span> (weight &gt; <span class="hljs-number">0</span> &amp;&amp; actualPosition &lt; <span class="hljs-keyword">this</span>.widthPassResultSize);
		<span class="hljs-keyword">for</span> (pixelOffset = <span class="hljs-number">0</span>; pixelOffset &lt; <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels;) {
			outputBuffer[outputOffset++] = <span class="hljs-built_in">Math</span>.round(output[pixelOffset++] * ratioWeightDivisor);
			outputBuffer[outputOffset++] = <span class="hljs-built_in">Math</span>.round(output[pixelOffset++] * ratioWeightDivisor);
			outputBuffer[outputOffset++] = <span class="hljs-built_in">Math</span>.round(output[pixelOffset++] * ratioWeightDivisor);
		}
	} <span class="hljs-keyword">while</span> (outputOffset &lt; <span class="hljs-keyword">this</span>.finalResultSize);
	<span class="hljs-keyword">return</span> outputBuffer;
}
Resize.prototype.resizeHeightInterpolated = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer)</span> </span>{
	<span class="hljs-keyword">var</span> ratioWeight = <span class="hljs-keyword">this</span>.ratioWeightHeightPass;
	<span class="hljs-keyword">var</span> weight = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> finalOffset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> pixelOffset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> pixelOffsetAccumulated = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> pixelOffsetAccumulated2 = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> firstWeight = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> secondWeight = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> outputBuffer = <span class="hljs-keyword">this</span>.heightBuffer;</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Handle for only one interpolation input being valid for start calculation:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (; weight &lt; <span class="hljs-number">1</span>/<span class="hljs-number">3</span>; weight += ratioWeight) {
		<span class="hljs-keyword">for</span> (pixelOffset = <span class="hljs-number">0</span>; pixelOffset &lt; <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels;) {
			outputBuffer[finalOffset++] = <span class="hljs-built_in">Math</span>.round(buffer[pixelOffset++]);
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Adjust for overshoot of the last pass’s counter:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	weight -= <span class="hljs-number">1</span>/<span class="hljs-number">3</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> interpolationHeightSourceReadStop = <span class="hljs-keyword">this</span>.heightOriginal - <span class="hljs-number">1</span>; weight &lt; interpolationHeightSourceReadStop; weight += ratioWeight) {</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Calculate weightings:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		secondWeight = weight % <span class="hljs-number">1</span>;
		firstWeight = <span class="hljs-number">1</span> - secondWeight;</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Interpolate:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		pixelOffsetAccumulated = <span class="hljs-built_in">Math</span>.floor(weight) * <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels;
		pixelOffsetAccumulated2 = pixelOffsetAccumulated + <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels;
		<span class="hljs-keyword">for</span> (pixelOffset = <span class="hljs-number">0</span>; pixelOffset &lt; <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels; ++pixelOffset) {
			outputBuffer[finalOffset++] = <span class="hljs-built_in">Math</span>.round((buffer[pixelOffsetAccumulated++] * firstWeight) + (buffer[pixelOffsetAccumulated2++] * secondWeight));
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Handle for only one interpolation input being valid for end calculation:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">while</span> (finalOffset &lt; <span class="hljs-keyword">this</span>.finalResultSize) {
		<span class="hljs-keyword">for</span> (pixelOffset = <span class="hljs-number">0</span>, pixelOffsetAccumulated = interpolationHeightSourceReadStop * <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels; pixelOffset &lt; <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels; ++pixelOffset) {
			outputBuffer[finalOffset++] = <span class="hljs-built_in">Math</span>.round(buffer[pixelOffsetAccumulated++]);
		}
	}
	<span class="hljs-keyword">return</span> outputBuffer;
}
Resize.prototype.resizeHeightRGBA = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer)</span> </span>{
	<span class="hljs-keyword">var</span> ratioWeight = <span class="hljs-keyword">this</span>.ratioWeightHeightPass;
	<span class="hljs-keyword">var</span> ratioWeightDivisor = <span class="hljs-number">1</span> / ratioWeight;
	<span class="hljs-keyword">var</span> weight = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> amountToNext = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> actualPosition = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> currentPosition = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> pixelOffset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> outputOffset = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">var</span> output = <span class="hljs-keyword">this</span>.outputHeightWorkBench;
	<span class="hljs-keyword">var</span> outputBuffer = <span class="hljs-keyword">this</span>.heightBuffer;
	<span class="hljs-keyword">do</span> {
		<span class="hljs-keyword">for</span> (pixelOffset = <span class="hljs-number">0</span>; pixelOffset &lt; <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels;) {
			output[pixelOffset++] = <span class="hljs-number">0</span>;
			output[pixelOffset++] = <span class="hljs-number">0</span>;
			output[pixelOffset++] = <span class="hljs-number">0</span>;
			output[pixelOffset++] = <span class="hljs-number">0</span>;
		}
		weight = ratioWeight;
		<span class="hljs-keyword">do</span> {
			amountToNext = <span class="hljs-number">1</span> + actualPosition - currentPosition;
			<span class="hljs-keyword">if</span> (weight &gt;= amountToNext) {
				<span class="hljs-keyword">for</span> (pixelOffset = <span class="hljs-number">0</span>; pixelOffset &lt; <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels;) {
					output[pixelOffset++] += buffer[actualPosition++] * amountToNext;
					output[pixelOffset++] += buffer[actualPosition++] * amountToNext;
					output[pixelOffset++] += buffer[actualPosition++] * amountToNext;
					output[pixelOffset++] += buffer[actualPosition++] * amountToNext;
				}
				currentPosition = actualPosition;
				weight -= amountToNext;
			}
			<span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">for</span> (pixelOffset = <span class="hljs-number">0</span>, amountToNext = actualPosition; pixelOffset &lt; <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels;) {
					output[pixelOffset++] += buffer[amountToNext++] * weight;
					output[pixelOffset++] += buffer[amountToNext++] * weight;
					output[pixelOffset++] += buffer[amountToNext++] * weight;
					output[pixelOffset++] += buffer[amountToNext++] * weight;
				}
				currentPosition += weight;
				<span class="hljs-keyword">break</span>;
			}
		} <span class="hljs-keyword">while</span> (weight &gt; <span class="hljs-number">0</span> &amp;&amp; actualPosition &lt; <span class="hljs-keyword">this</span>.widthPassResultSize);
		<span class="hljs-keyword">for</span> (pixelOffset = <span class="hljs-number">0</span>; pixelOffset &lt; <span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels;) {
			outputBuffer[outputOffset++] = <span class="hljs-built_in">Math</span>.round(output[pixelOffset++] * ratioWeightDivisor);
			outputBuffer[outputOffset++] = <span class="hljs-built_in">Math</span>.round(output[pixelOffset++] * ratioWeightDivisor);
			outputBuffer[outputOffset++] = <span class="hljs-built_in">Math</span>.round(output[pixelOffset++] * ratioWeightDivisor);
			outputBuffer[outputOffset++] = <span class="hljs-built_in">Math</span>.round(output[pixelOffset++] * ratioWeightDivisor);
		}
	} <span class="hljs-keyword">while</span> (outputOffset &lt; <span class="hljs-keyword">this</span>.finalResultSize);
	<span class="hljs-keyword">return</span> outputBuffer;
}
Resize.prototype.resize = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer)</span> </span>{
	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.useWebWorker) {
		<span class="hljs-keyword">this</span>.worker.postMessage([<span class="hljs-string">"resize"</span>, buffer]);
	}
	<span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">this</span>.resizeCallback(<span class="hljs-keyword">this</span>.resizeHeight(<span class="hljs-keyword">this</span>.resizeWidth(buffer)));
	}
}
Resize.prototype.bypassResizer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(buffer)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Just return the buffer passsed:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> buffer;
}
Resize.prototype.initializeFirstPassBuffers = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(BILINEARAlgo)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Initialize the internal width pass buffers:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.widthBuffer = <span class="hljs-keyword">this</span>.generateFloatBuffer(<span class="hljs-keyword">this</span>.widthPassResultSize);
	<span class="hljs-keyword">if</span> (!BILINEARAlgo) {
		<span class="hljs-keyword">this</span>.outputWidthWorkBench = <span class="hljs-keyword">this</span>.generateFloatBuffer(<span class="hljs-keyword">this</span>.originalHeightMultipliedByChannels);
	}
}
Resize.prototype.initializeSecondPassBuffers = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(BILINEARAlgo)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Initialize the internal height pass buffers:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.heightBuffer = <span class="hljs-keyword">this</span>.generateUint8Buffer(<span class="hljs-keyword">this</span>.finalResultSize);
	<span class="hljs-keyword">if</span> (!BILINEARAlgo) {
		<span class="hljs-keyword">this</span>.outputHeightWorkBench = <span class="hljs-keyword">this</span>.generateFloatBuffer(<span class="hljs-keyword">this</span>.targetWidthMultipliedByChannels);
	}
}
Resize.prototype.generateFloatBuffer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(bufferLength)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Generate a float32 typed array buffer:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">try</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float32Array</span>(bufferLength);
	}
	<span class="hljs-keyword">catch</span> (error) {
		<span class="hljs-keyword">return</span> [];
	}
}
Resize.prototype.generateUint8Buffer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(bufferLength)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Generate a uint8 typed array buffer:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">try</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(bufferLength);
	}
	<span class="hljs-keyword">catch</span> (error) {
		<span class="hljs-keyword">return</span> [];
	}
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
